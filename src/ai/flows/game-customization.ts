// This is an autogenerated file from Firebase Studio.
'use server';

/**
 * @fileOverview A flow to adjust the difficulty level of a game based on vocabulary level.
 *
 * - customizeGameDifficulty - A function that handles the game difficulty customization process.
 * - CustomizeGameDifficultyInput - The input type for the customizeGameDifficulty function.
 * - CustomizeGameDifficultyOutput - The return type for the customizeGameDifficulty function.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';

const CustomizeGameDifficultyInputSchema = z.object({
  documentText: z.string().describe('The text content of the uploaded document.'),
  gameType: z.string().describe('The type of game to customize (e.g., Wordscapes, Drops).'),
  desiredDifficulty: z
    .enum(['easy', 'medium', 'hard'])
    .describe('The desired difficulty level for the game.'),
});
export type CustomizeGameDifficultyInput = z.infer<
  typeof CustomizeGameDifficultyInputSchema
>;

const WordscapesRoundSchema = z.object({
    letters: z.array(z.string()).min(5).max(7).describe('An array of 5-7 letters for the user to form words from.'),
    mainWords: z.array(z.string()).describe('A list of primary words (3+ letters) for the user to find, which will be displayed in the grid. Every word in this list MUST be a valid, real English word and MUST be formable using only the provided letters.'),
    bonusWords: z.array(z.string()).describe('An additional list of valid, real English words (3+ letters) that can be formed but are not in the main grid. This list must not contain any words from mainWords. Every word in this list MUST be formable using only the provided letters.'),
});

const SpellingBeeRoundSchema = z.object({
    letters: z.array(z.string()).length(7).describe('An array of exactly 7 letters for the user to form words from.'),
    centerLetter: z.string().length(1).describe('The mandatory center letter that must be included in every word.'),
    mainWords: z.array(z.string()).describe('A list of primary words (4+ letters) for the user to find. Every word MUST be a valid, real English word, be at least 4 letters long, MUST be formable using only the provided 7 letters, and MUST include the centerLetter.'),
    bonusWords: z.array(z.string()).describe('An additional list of valid, real English words that meet all the criteria but are not part of the main list. This list must not contain any words from mainWords.'),
});


const SimpleGameRoundSchema = z.object({
    miniGameType: z.enum(['unscramble']).describe("The type of this mini-game round."),
    word: z.string().describe('The correct word for the round.'),
    scrambled: z.string().describe('The scrambled/jumbled version of the word to show the user.'),
    displayPrompt: z.string().describe('The prompt to show the user for this round (e.g., "Unscramble the word").')
});

const MultipleChoiceRoundSchema = z.object({
    miniGameType: z.enum(['multiple-choice']).describe("The type of this mini-game round."),
    question: z.string().describe("The question or definition to ask the user."),
    options: z.array(z.string()).describe("A list of 4 possible answers."),
    correctAnswer: z.string().describe("The correct answer from the options."),
});

const TrueFalseRoundSchema = z.object({
    miniGameType: z.enum(['true-false']).describe("The type of this mini-game round."),
    statement: z.string().describe("A statement to present to the user."),
    isTrue: z.boolean().describe("Whether the statement is true or false."),
});

const MemoryRoundSchema = z.object({
    miniGameType: z.enum(['memory']).describe("The type of this mini-game round."),
    wordsToShow: z.array(z.string()).describe("A list of 5-8 words to show the user briefly."),
    question: z.string().describe("A question about the words shown, e.g., 'Which of these words was in the list?'"),
    options: z.array(z.string()).describe("A list of 4 possible answers."),
    correctAnswer: z.string().describe("The correct answer from the options."),
});

const CategorizationRoundSchema = z.object({
    miniGameType: z.enum(['categorization']).describe("The type of this mini-game round."),
    question: z.string().describe("The question asking which item does not belong."),
    options: z.array(z.string()).describe("A list of 4 words, where 3 belong to a category and 1 does not."),
    correctAnswer: z.string().describe("The word that does not belong to the category."),
});


const GameRoundSchema = z.union([SimpleGameRoundSchema, MultipleChoiceRoundSchema, TrueFalseRoundSchema, MemoryRoundSchema, CategorizationRoundSchema]);

const CustomizeGameDifficultyOutputSchema = z.object({
    gameTitle: z.string().describe('The title for this specific game session.'),
    gameType: z.string().describe('The type of game being played, to be passed to the client.'),
    gameData: z.union([WordscapesRoundSchema, SpellingBeeRoundSchema, z.array(GameRoundSchema)]).describe('The customized data for the game. The structure depends on the gameType.'),
});

export type CustomizeGameDifficultyOutput = z.infer<
  typeof CustomizeGameDifficultyOutputSchema
>;

export async function customizeGameDifficulty(
  input: CustomizeGameDifficultyInput
): Promise<CustomizeGameDifficultyOutput> {
  return customizeGameDifficultyFlow(input);
}

const prompt = ai.definePrompt({
  name: 'customizeGameDifficultyPrompt',
  input: {schema: CustomizeGameDifficultyInputSchema},
  output: {schema: CustomizeGameDifficultyOutputSchema},
  prompt: `You are a brilliant educational game designer specializing in cognitive training. Your task is to generate a customized game level based on a user's uploaded document and selected game type.

Document Text: {{{documentText}}}
Game Type: {{{gameType}}}
Desired Difficulty: {{{desiredDifficulty}}}

Generate a creative and relevant title for this game session.

Based on the game type, prepare the 'gameData':

**If the game is 'Wordscapes' or 'Word Cookies':**
1.  **Analyze and Extract:** Analyze the document text to identify 10-15 key vocabulary words that match the 'desiredDifficulty'.
2.  **Select Base Letters:** Choose the longest and most interesting word from the extracted list to be the source for the letter wheel. This word should have 5-7 unique letters. If no single word works, create a compelling set of 5-7 letters based on the document's themes.
3.  **Generate Word List:** From the chosen 5-7 letters, find ALL possible valid, real English words of 3 or more letters.
4.  **CRITICAL RULE:** Every word you generate for 'mainWords' and 'bonusWords' MUST be formable using ONLY the letters you selected in step 2, respecting letter counts. For example, if you have one 'L', a word cannot use two 'L's. Do not include any words that use letters not in your selected set. Every word must be a real, dictionary-valid English word.
5.  **Create Game Level:**
    *   **letters**: An array of the 5-7 letters for the wheel.
    *   **mainWords**: Select 5-12 of the most relevant or common words from the generated list, ensuring a good mix of word lengths. The 'mainWords' and 'bonusWords' lists MUST NOT contain any of the same words.
    *   **bonusWords**: All other valid words from the generated list that are NOT in 'mainWords' become bonus words.
6.  The 'gameData' field should be a single object matching the 'WordscapesRoundSchema'.

**If the game is 'Spelling Bee (NYT)':**
1.  **Analyze and Extract:** Analyze the document to identify key vocabulary and themes matching the 'desiredDifficulty'.
2.  **Select 7 Letters:** Choose a set of exactly 7 unique letters from the document's vocabulary. These letters should allow for the formation of many words, including at least one "pangram" (a word using all 7 letters).
3.  **Designate Center Letter:** From the 7 letters, select one to be the mandatory 'centerLetter'. This letter should be common and appear in a large number of the potential words.
4.  **Generate Word Lists:** Find all possible valid, real English words that meet the following criteria:
    *   Must be at least 4 letters long.
    *   Must be formable using ONLY the 7 chosen letters.
    *   **CRITICAL RULE:** MUST include the 'centerLetter'.
5.  **Create Game Level:**
    *   **letters**: The array of 7 letters.
    *   **centerLetter**: The single mandatory letter.
    *   **mainWords**: A list of the most common/important words from the generated list that meet all criteria.
    *   **bonusWords**: Any other valid words from the list that are not in 'mainWords'.
6.  The 'gameData' field should be a single object matching the 'SpellingBeeRoundSchema'.


**If the game is 'Drops' or 'Elevate':**
1.  **Analyze and Extract:** Analyze the document to extract a list of 20-30 key vocabulary words, concepts, and their definitions/context, suitable for the desired difficulty.
2.  **Create 5-Minute Session:** Generate an array of approximately 20-25 varied mini-game rounds that can be completed in a 5-minute session. The goal is rapid-fire engagement.
3.  **Vary Mini-Games:** The generated array should be a mix of the following schemas: (\`SimpleGameRoundSchema\`), (\`MultipleChoiceRoundSchema\`), (\`TrueFalseRoundSchema\`), (\`MemoryRoundSchema\`), and (\`CategorizationRoundSchema\`).
    *   For **'unscramble'** (\`SimpleGameRoundSchema\`): Pick a word, scramble it, and set the prompt to "Unscramble the letters."
    *   For **'multiple-choice'** (\`MultipleChoiceRoundSchema\`): Use a word's definition as the 'question'. The 'options' should be four words, one of which is correct. The other three should be plausible but incorrect distractors from the document.
    *   For **'true-false'** (\`TrueFalseRoundSchema\`): Create a statement like "'{word}' means '{definition}'". Randomly make the definition correct or incorrect (from another word in the document).
    *   For **'memory'** (\`MemoryRoundSchema\`): Briefly show the user a list of 5-8 words from the document. Then, ask a multiple-choice question like "Which of these words was in the list you just saw?". One option is correct, the others are plausible distractors.
    *   For **'categorization'** (\`CategorizationRoundSchema\`): Present four words. Three should belong to a clear category (e.g., types of fish, words related to space) from the document, and one should be an outlier. The user must select the word that doesn't belong.
4.  The 'gameData' field should be an array of objects, each matching one of the varied round schemas.

Set the 'gameType' in the output to be the same as the input 'gameType'. This is crucial for the client to render the correct UI.`,
});

const customizeGameDifficultyFlow = ai.defineFlow(
  {
    name: 'customizeGameDifficultyFlow',
    inputSchema: CustomizeGameDifficultyInputSchema,
    outputSchema: CustomizeGameDifficultyOutputSchema,
  },
  async (input) => {
    let attempts = 0;
    while (attempts < 2) {
      try {
        const {output} = await prompt(input);
        return output!;
      } catch (error: any) {
        attempts++;
        if (attempts >= 2) {
          console.error("AI call failed after multiple attempts:", error);
          throw new Error("The AI model is currently overloaded. Please try again in a few moments.");
        }
        console.log("AI call failed, retrying...", error.message);
        // Wait for a second before retrying
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }
    // This part should be unreachable, but it satisfies TypeScript's need for a return path.
    throw new Error("Failed to get a response from the AI model.");
  }
);
